\documentclass[pdf]{beamer}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{natbib}
\usepackage{upgreek}
\usepackage{stmaryrd}

\mode<presentation>{}

\newcommand{\T}[1]{\texttt{#1}}
\newsavebox{\codebox}
\newsavebox{\lengthbox}
\lstset{mathescape=true, basicstyle=\ttfamily}
\newcommand{\LP}{\langle}
\newcommand{\RP}{\rangle}
\newcommand{\LB}{\llbracket}
\newcommand{\RB}{\rrbracket}
\newcommand{\LL}{\langle\!\langle}
\newcommand{\RR}{\rangle\!\rangle}
\newcommand{\quadthree}{\qquad\quad}
\newcommand{\quadfour}{\quadthree\quad}
\newcommand{\quadfive}{\quadfour\quad}
\newcommand{\quadsix}{\quadfive\quad}
\newcommand{\quadseven}{\quadsix\quad}
\newcommand{\quadeight}{\quadseven\quad}
\newcommand{\quadten}{\quadfive\quadfive}

\title{Extracting Cost Recurrences from Sequential and Parallel Functional Programs}

\author{Justin Raymond}
\institute{Professor Norman Danner}

%\usecolortheme{fly}
%\setbeameroption{show notes}


\begin{document}

\begin{lrbox}{\codebox}
\begin{lstlisting}
rev = $\lambda$xs.rec(xs,
  Nil $\mapsto$ $\lambda$a.a,
  Cons$\mapsto \LP x,\LP xs,r \RP\RP.\lambda$a.force(r) Cons$\LP$x,a$\RP$))) Nil
\end{lstlisting}
\end{lrbox}

\defverbatim[colored]\lstfold{
  \begin{lstlisting}[language=Caml, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
  fold f z xs =
    match xs with
      [] -> z
      x::xs' -> f x (fold f z xs')
  \end{lstlisting}
}

\defverbatim[colored]\lstlength{
  \begin{lstlisting}[language=Caml, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
  length xs =
    match xs with
     [] -> 0
     (x::xs) -> 1 + length xs
  \end{lstlisting}
}

\defverbatim[colored]\lstfastreverse{
  \begin{lstlisting}[language=Caml, xleftmargin=.05\textwidth, xrightmargin=.05\textwidth]
  rev ys =
    let go xs =
      match xs with
       [] -> fun ys -> ys
       (x::xs') -> fun a -> (go xs') (x::a)
    in go ys []
  \end{lstlisting}
}

\defverbatim[colored]\lstinsert{
  \begin{lstlisting}[language=Caml, xleftmargin=.05\textwidth, xrightmargin=.05\textwidth]
  insert f y xs =
    match xs with
      [] -> [y]
      x::xs' | f y x -> y::xs
      x::xs' -> x::insert f y xs'
  \end{lstlisting}
}
\defverbatim[colored]\lstsort{
  \begin{lstlisting}[language=Caml, xleftmargin=.05\textwidth, xrightmargin=.05\textwidth]
  sort f xs =
    match xs with
      [] -> []
      x::xs' -> insert f x (sort f xs')
  \end{lstlisting}
}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Overview}
  \begin{itemize}
    \item Complexity analysis aims to predict the resources, most often time and space, which a program requires
    \vfill
    \item Previous work by \citet{Danner2013} and \citet{Danner2015} formalizes the analysis of higher-order function programs
    \vfill
    \item We use the method of \citet{Danner2015} to analyze higher order functional programs
    \vfill
    \item We extend the method to parallel cost semantics
    \vfill
    \item We prove an interesting fact about the recurrences for the cost of programs
  \end{itemize}
\note{\tiny Complexity analysis aims to predict the resources, most often time and
space, which a program requires. Traditiional complexity analysis, you look at
the program, you write down a recurrence which describes the cost, you solve
the recurrence, you drop everything but the highest order term. There are
drawbacks to this approach. The foremost is that there is no formal
relationship between the source language program and the recurrence. This makes
it easier to make mistakes. The second drawback is the traditional approach is
not compositional. To analyze the composition of two functions $g \circ f$ we
need to know something about the size of the result of $f$. This gets more
complicated with higher order functions such as \T{fold}.}

\note{ My thesis comes in three parts. In the first part I analyze the cost of
higher-order functional programs. I go through the analysis in complete detail.
In the second part I demonstrate the flexibility of the formalism by changing
the cost model to parallel cost semantics. In the third part I prove an
interesting theorem about the recurrences extracted from source language
programs.
}
\end{frame}

\begin{frame}{Complexity Analysis}
  \begin{itemize}
    \item[]Source program
      \lstfold
      \vfill
    \item[]Recurrence for cost
      \[ T(n) = \begin{cases}
          &c_0 \text{ if } n = 0 \\
          &c_1 + T(n-1) \text{ otherwise}
        \end{cases}
      \]
      \vfill
    \item[]Closed form solution
      \[T(n) = c_1 n + c_1 = \mathcal{O}(n)\]

  \end{itemize}

  \note{Traditional complexity analysis of a recursive program, we write down a
  recurrence for the cost of the program. Then we solve the recurrence and drop
the constant factors. There is no formal relation between the program and the
recurrence.}

  \note{Can we make this analysis higher-order? How do we take into account the
    asymptotic complexity of $f$?

    We could try to say that $f$ is $\mathcal{O}(x)$ where $x$ is the size of
    the sum of its arguments. But how big are the sum of the arguments to $f$?

    The size of the inputs to $f$ depend on the size of each element in the
    list and the size of recursive calls to \T{fold}.

    How to address this? Enter the \citet{Danner2015}.
  }
\end{frame}

\begin{frame}{Overview}
  \begin{itemize}
    \item Write programs in a "source language"
    \vfill
    \item Translate the programs to a "complexity language"
    \vfill
    \item The translated programs are recurrences for the complexity of the source language program
    \vfill
    \item \textbf{complexity} = cost $\times$ potential
    \vfill
    \item \textbf{cost}: steps to run a program
    \vfill
    \item \textbf{potential}: size of the result of evaluating program
  \end{itemize}

  \note{How do anaylsis in a way that we have a formal connection between the
  program and the recurrence, is naturally higher-order, and compositional?

  Previous work by \citet{Danner2013} and \citet{Danner2015} developed a method
  to address this. The overview of the approach is the programmer writes their
  programs in a source language. Then the source language program is translated
  to whats called a complexity language. The complexity language is essentially
  a language for expressing the recurrence for the complexity of the source
  language program. What is a complexity? A complexity is a pair of a cost and
  a potential. The cost is a bound on the steps required to run the program.
  The potential is the size of the result of evaluating the program.
}
\end{frame}

\begin{frame}{Source Language}
  \begin{itemize}
    \item Variant of System-T
      \begin{align*}
        e ::=\ &x\ |\ \LP\RP\ |\ \lambda x.e\ |\ e\ e\ |\ \LP e,e\RP\ |\ \T{split}(e, x.x.e) \\
               &|\ \T{delay}(e)\ |\ \T{force}(e)|\ C^\delta\ e\ |\ \T{rec}^\delta(e, \overline{C \mapsto x.e_C}) \\
               &|\ \T{map}^\phi(x.v, v)\ |\ \T{let}(e, x.e)
      \end{align*}
    \vfill
    \item Programmer defined datatypes
      \begin{itemize}
        \item \T{datatype list = Nil | Cons int$\times$list}
      \end{itemize}
    \vfill
    \item Structural Recursion
      \begin{itemize}
        \item OCaml: \lstlength
        \item $\lambda xs.\T{rec}(xs, \T{Nil}\mapsto 0, \T{Cons}\mapsto\LP x,\LP xs,r\RP\RP.1 + \T{force}(r))$
      \end{itemize}
    \vfill
  \end{itemize}

  \note{\tiny
    So what does the source language look like? It is a variant of System
    T. If you're like me and can never remember the differences between the
    variants on the lambda calculus, System T is the simply typed lambda
    calculus with primitive recursion. The source language as structural
    recursion as well as some additional mechanisms to control the cost of
    programs. So we have \T{let} expressions to avoid recomputations of values
    and suspensions to evaluating expressions we don't actually need.

    The source language also has programmer-defined datatypes. Here is an
    example of how you would define a list. The arguments to the constructor of
    a datatype must be strictly positive.

    As an example of what the source language program looks like. Here is a
    recursive function that computes the length of a list in OCaml and the same
    function in the source language. The \T{rec} construct gives us structural
    recursion. It evaluates an expression to a value, and based on the
    constructor of the value, evaluates to the appropriate branch. Inside the
    branch we are given access to the arguments to the constructor as well as a
    delayed computation representing the result of the recursive call.
  }
\end{frame}


\begin{frame}{Sequential Cost Semantics}
  \begin{itemize}
      \vfill
    \item[]
      \begin{prooftree}
        \AxiomC{$e_0 \downarrow^{n_0} v_0$}
        \AxiomC{$e_1 \downarrow^{n_1} v_1$}
        \BinaryInfC{$\LP e_0, e_1 \RP \downarrow^{n_0 + n_1} \LP v_0, v_1 \RP$}
      \end{prooftree}
      \vfill
    \item[]
      \begin{prooftree}
      \AxiomC{$e_0 \downarrow^{n_0} \lambda x.e_0'$}
      \AxiomC{$e_1 \downarrow^{n_1} v_1$}
      \AxiomC{$e_0'[v_1/x] \downarrow^n v$}
      \TrinaryInfC{$e_0\ e_1 \downarrow^{1 + n_0 + n_1 + n} v$}
      \end{prooftree}
      \vfill
    %\item[]
    %  \tiny
    %  \begin{prooftree}
    %    \AxiomC{$e \downarrow^{n_0} C v_0$}
    %    \AxiomC{$\T{map}^{\phi_C}(y.\LP y, \T{delay}(rec(y, \overline{C \mapsto x.e_C}))\RP, v_0) \downarrow^{n_1} v_1$}
    %    \AxiomC{$e_C[v_1/x] \downarrow^{n_2} v$}
    %    \TrinaryInfC{$rec(e, \overline{C \mapsto x.e_C}) \downarrow^{1 + n_0 + n_1 + n_2} v$}
    %  \end{prooftree}
      \vfill
    \item[]
      \begin{figure}
        \AxiomC{}
        \UnaryInfC{$\T{delay}(e) \downarrow^0 \T{delay}(e)$}
        \DisplayProof
        \qquad
        \AxiomC{$e \downarrow^{n_0} \T{delay}(e_0)$}
        \AxiomC{$e_0 \downarrow^{n_1} v$}
        \BinaryInfC{$\T{force}(e) \downarrow^{n_0 + n_1} v$}
        \DisplayProof
      \end{figure}
      \vfill
  \end{itemize}

  \note{The semantics of the source language are given by operation cost
    semantics. Operational cost semantics are big step operational semantics
    but include a notion of steps to execute the program. The judgments are of
    the form $e$ steps to $v$ in $n$ steps.
  }
\end{frame}

\begin{frame}{Complexity Language}
  \begin{itemize}
    \item Source language without syntactic constructs for controlling costs
    \item Types
      \begin{align*}
        T &::= \textbf{C} \ |\ \T{unit} \ |\ \Delta \ |\ T \times T \ |\ T \rightarrow T \\
        \Phi &::= t \ |\ T \ |\ \Phi \times \Phi \ |\ T \rightarrow \Phi \\
        \textbf{C} &::= 0\ |\ 1\ |\ 2\ |\ ... \\
        \T{datatype}\Delta &= C^\Delta_0 \T{of} \Phi_{C_0}[\Delta] \ |\ ... \ |\ C^\Delta_{n-1} \T{of} \Phi_{C_{n-1}}[\Delta]
      \end{align*}
    \item Expressions
      \begin{align*}
        E &::= x | 0 | 1 | E + E | \LP\RP | \LP E,E \RP | \\
          &\quad \pi_0 E | \pi_1 E | \lambda x.E | E\ E | C^\delta\ E | \text{rec}^\Delta(E, \overline{C \mapsto x.E_C})
      \end{align*}
    \vfill
    \item No longer need mechanisms for controlling cost
  \end{itemize}
\end{frame}

\begin{frame}{Translation}
  \begin{itemize}
    \item Translate source language programs of type $\tau$ to complexity language programs of type $\textbf{C}\times \LL \tau \RR$
    \vfill
    \item \textbf{C} bound on the steps to evaluate the program
    \vfill
    \item $\LL\tau\RR$ expression for the size of the value
    \vfill
    \item Types of the translation function $\|\cdot\|$:
      \begin{align*}
        \|\tau\| &= \textbf{C} \times \LL \tau \RR \\
        \LL\T{unit}\RR &= \T{unit} \\
        \LL \sigma \times \tau \RR &= \LL \sigma \RR \times \LL \tau \RR \\
        \LL \sigma \rightarrow \tau \RR &= \LL \sigma \RR \rightarrow \|\tau\| \\
        \LL \T{susp}\ \tau \RR &= \|\tau\| \\
        \LL \delta \RR &= \delta \\
      \end{align*}
  \end{itemize}
\end{frame}

\begin{frame}{Translation}
  \begin{itemize}
    \item[] Some cases of the translation function
      \begin{align*}
        \|x\| &= \LP 0,x \RP \\
        \|\LP e_0,e_1 \RP\| &= \LP \|e_0\|_c + \|e_1\|_c, \LP \|e_0\|_p,\|e_1\|_p\RP\RP \\
        \|\lambda x.e\| &= \LP 0, \lambda x.\|e\|\RP \\
        \|e_0\ e_1\| &= (1 + \|e_0\|_c + \|e_1\|_c) +_c \|e_0\|_p \|e_1\|_p \\
        \|\T{delay}(e)\| &= \LP 0,\|e\| \RP \\
        \|\T{force}(e)\| &= \|e\|_c +_c \|e\|_p
      \end{align*}
  \end{itemize}
\end{frame}


\begin{frame}{Fast Reverse - Specification and Implementation}
  \begin{itemize}
    \item
        $\T{datatype list} = \T{Nil of unit}\ |\ \T{Cons of int} \times \T{list}$
    \item
      Specification: \T{rev [$x_0,\dots,x_{n-1}$] = [$x_{n-1},\dots,x_0$]}
    \item
      Implementation:
      \usebox{\codebox}
    \item[]
      \lstfastreverse
      %Specification of auxilary function:\\
      %\T{rec($[x_0,\dots,x_{n-1}],\dots$) [$y_0,\dots,y_{m-1}$] = [$x_{n-1},\dots,x_0,y_0,\dots,y_{m-1}$]}
  \end{itemize}
\end{frame}

\begin{frame}{Fast Reverse - Specification and Implementation}
  \begin{itemize}
    \item
      \T{rev (Cons$\LP$0,Cons$\LP$1, Nil$\RP\RP$)}
    \item
    \T{$\to_\beta$
      rec(Cons$\LP$0,Cons$\LP$1,Nil$\RP\RP$,
          Nil $\mapsto\lambda$a.a
          Cons$\mapsto \LP x,\LP xs,r\RP\RP.\lambda$a.force(r) Cons$\LP$x,a$\RP$) Nil}
    \item
      \T{$\to^*_\beta (\lambda$a0.($\lambda$a1.($\lambda$a2.a2) Cons$\LP$1,a1$\RP$) Cons$\LP$0,a0$\RP$) Nil}
    \item
      $\to_\beta$ ($\lambda$a1.($\lambda$a2.a2) Cons$\LP$1,a1$\RP$) Cons$\LP$0,Nil$\RP$
    \item
      $\to_\beta$ ($\lambda$a2.a2) Cons$\LP$1,Cons$\LP$0,Nil$\RP\RP$
    \item
      $\to_\beta$ Cons$\LP$1,Cons$\LP$0,Nil$\RP\RP$
  \end{itemize}
\end{frame}

\begin{frame}{Fast Reverse - Translation}
  \small
  \begin{itemize}
    \item $\|\T{rev}\|$
      \begin{align*}
       &\LP 0, \lambda xs. 1 +_c \T{rec}(xs, \T{Nil} \mapsto \LP 1, \lambda a. \LP 0,a \RP\RP \\
      &\quad \T{Cons}\mapsto \LP x, \LP xs', r\RP\RP.\LP 1, \lambda a.(1 + r_c) +_c r_p\ \T{Cons}\LP \pi_1 x, a \RP\RP)\ \T{Nil}\RP\\
      \end{align*}
    \item $\|\T{rev xs}\|$
    \begin{align*}
      &1 +_c (\lambda xs.\T{rec}(xs, \T{Nil} \mapsto \LP 1, \lambda a. \LP 0, a \RP \RP \\
  &\quad \T{Cons}\mapsto \LP x, \LP xs', r\RP\RP. \LP 1, \lambda a.(1 + r_c) +_c r_p\ \T{Cons}\LP x, a \RP \RP)\ \T{Nil})\ xs
    \end{align*}
  \end{itemize}
\end{frame}

\begin{frame}{Fast Reverse - Interpretation}
  We need to provide an interpretation for programmer-defined datatypes
  \begin{flalign*}
    \LB \T{list} \RB &= \mathbb{N}\\
    D^{list} &= \{\ast\} + \{1\} \times \mathbb{N}\\
    size_{list}(\ast) &= 1\\
    size_{list}(1,n) &= 1 + n\\
  \end{flalign*}
  The interpretation of the recursor is
  \begin{align*}
    g(n) &= \bigvee\limits_{size\ z \leq n} case(z, f_C, f_N) \\
  &\text{where} \\
    f_{Nil}(x) &= (1, \lambda a.(0, a)) \\
   f_{Cons}(b) &= (1, \lambda a. (1 + g_c(\pi_1 b)) +_c g_p(\pi_1 b)\ (a + 1))\\
  \end{align*}
\end{frame}

\begin{frame}{Fast Reverse - Interpretation}
  \begin{itemize}
    \item Let $h(n, a) = g_p(n)\ a$.
    \item The recurrence for the cost:
      \begin{equation}
        h_c(n,a) = \begin{cases}
          0 & n = 0 \\
          2 + h_c(n-1,a+1) & n > 0
        \end{cases}
      \end{equation}
    \item$h_c(n,a) = 2n$
    \item The recurrence for the potential:
      \begin{equation}
        h_p(n,a) = \begin{cases}
          a & n = 0 \\
          h_p(n-1,a+1) & n > 0
        \end{cases}
      \end{equation}
    \item $h_p(n,a) = n + a$
  \end{itemize}
\end{frame}

\begin{frame}{Parametric Insertion Sort - Source Language Insert}
  \small
  \begin{itemize}
    \vfill
    \item[]
      $\T{data list} = \T{Nil of unit | Cons of int $\times$ list}$
    \vfill
    \item[]
      \begin{flalign*}
        \T{insert} &= \lambda f.\lambda x.\lambda xs.\T{rec}(xs, \T{Nil} \mapsto \T{Cons} \LP x, \T{Nil}\RP, &\\
                   &\qquad \T{Cons}\mapsto \LP y, \LP ys,r \RP\RP.\T{rec}(f\ x\ y, \T{True}\mapsto \T{Cons}\LP x,\T{Cons}\LP y,ys \RP\RP, &\\
                   &\qquad\quad \T{False}\mapsto \T{Cons}\LP y,\T{force}(r)\RP)) &
      \end{flalign*}
      \vfill
    \item[] \lstinsert
    \vfill
  \end{itemize}
\end{frame}

\begin{frame}{Parametric Insertion Sort - Source Language Sort}
  \small
  \begin{itemize}
    \vfill
    \item[]
      \begin{flalign*}
        \T{sort} &= \lambda f.\lambda xs.\T{rec}(xs, \T{Nil} \mapsto \T{Nil}, &\\
                 &\qquad \T{Cons} \mapsto \LP y,\LP ys,r \RP\RP.\T{insert}\ f\ y\ \T{force}(r)) &
      \end{flalign*}
    \vfill
    \item[] \lstsort
    \vfill
  \end{itemize}
\end{frame}

\begin{frame}{Parametric Insertion Sort - Complexity Language}
  \vfill
  \begin{align*}
    \|\T{insert}\| &= \LP 0, \lambda f. \LP 0, \lambda x.\LP 0,\lambda xs. \T{rec}(xs, \T{Nil} \mapsto \LP 1,\T{Cons}\LP x,\T{Nil}\RP\RP, \\
             &\quad\quad \T{Cons}\mapsto \LP y, \LP ys,r \RP\RP. (3 + (f x)_c) +_c \T{rec}(((f\ x)_p\ y)_p, \\
             &\quadten\T{True}\mapsto \LP 1, \T{Cons}\LP x,\T{Cons}\LP y,ys\RP\RP\RP, \\
             &\quadten\T{False}\mapsto \LP 1 + r_c, \T{Cons}\LP y,r_p\RP\RP)))
  \end{align*}
  \vfill
  \begin{align*}
    \|\T{sort}\| &= \LP 0, \lambda f.\LP 0,\lambda xs.\T{rec}(xs, \T{Nil} \mapsto 1 +_c \LP 0,\T{Nil}\RP, \\
               &\quad \T{Cons} \mapsto \LP y,\LP ys,r \RP\RP.(4 + r_c) +_c ((\|\T{insert}\|_p f)_p y)_p r_p)\RP\RP
  \end{align*}
  \vfill
\end{frame}

\begin{frame}{Parametric Insertion Sort - Insert Interpretation}
  \begin{itemize}
    \item[]
      \small
      \begin{align*}
      g(i,n) &= \bigvee\limits_{size(z) \leq (i,n)} case(z, f_{Nil}, f_{Cons}) \\
             &\text{where}\\
      f_{Nil}(\ast) &= (1, (i, 1)) \\
      f_{Cons}(j,m) &= (4 + (f\ i)_c) +_c ((1, (max(x,j), 2 + m)) \\
                    &\quadthree \vee (1 + g_c(j,m), (max(j,\pi_0 r_p), 1 + \pi_1 g_p(j,m))))
      \end{align*}
    \item Closed form solution for the cost:
      \[g_c(i,n) \leq (4 + ((f\ x)_p\ i)_c n + 1\]
    \item Closed form solution for the potential:
      \[g_p(i,n) \leq (max\{x, i\}, n+1)\]
  \end{itemize}
\end{frame}

\begin{frame}{Parametric Insertion Sort - Sort Interpretation}
  \begin{itemize}
    \item[]
      \small
      \begin{align*}
      g(i, n) &= \bigvee\limits_{size(z)\leq n} case(z, f_{Nil}, f_{Cons}) \\
      %
              &\text{where}\\
      f_{Nil} &= (1, (-\infty,0)) \\
    f_{Cons} &= (5 + g_c(j,m) + (f\ j)_p\ j)_c g_p(j,m), (max\{j,j\},g_p(j,m) + 1))
      \end{align*}
  %cost depends on potential
    \item Closed form solution for potential:
      \[g_p(i,n) \leq (i, n)\]
    \item Closed form solution for the cost:
      \[g_c(i,n) \leq (3 + ((f\ i)_p\ i)_c n^2 + 5n + 1\]
  \end{itemize}
\end{frame}


\begin{frame}{Parallel Cost Semantics}
  \begin{itemize}
    \item Cost graphs
      \[
        \mathcal{C} ::= 0\ |\  1\ |\  \mathcal{C} \oplus \mathcal{C}\ |\  \mathcal{C} \otimes \mathcal{C}
      \]
    \item[] Evaluation Semantics
      \begin{prooftree}
        \AxiomC{$e_0 \downarrow^{n_0} v_0$}
        \AxiomC{$e_1 \downarrow^{n_1} v_1$}
        \BinaryInfC{$\LP e_0, e_1 \RP \downarrow^{n_0 \otimes n_1} \LP v_0, v_1 \RP$}
        \end{prooftree}
        \begin{prooftree}
        \AxiomC{$e_0 \downarrow^{n_0} \lambda x.e_0'$}
        \AxiomC{$e_1 \downarrow^{n_1} v_1$}
        \AxiomC{$e_0'[v_1/x] \downarrow^n v$}
        \TrinaryInfC{$e_0\ e_1 \downarrow^{(n_0 \otimes n_1) \oplus n \oplus 1} v$}
        \end{prooftree}
  \end{itemize}
\end{frame}

\begin{frame}{Work and Span}
  \begin{itemize}
    \item \textbf{Work} total steps to run program
      \begin{equation*}
        work(c) = \begin{cases}
          0 &\text{if } c = 0 \\
          1 &\text{if } c = 1 \\
          work(c_0) + work(c_1) &\text{if } c = c_0 \otimes c_1 \\
          work(c_0) + work(c_1) &\text{if } c = c_0 \oplus c_1
        \end{cases}
      \end{equation*}
    \item \textbf{Span} critical path of program
      \begin{equation*}
        span(c) = \begin{cases}
          0 &\text{if } c = 0 \\
          1 &\text{if } c = 1 \\
          max(span(c_0), span(c_1)) &\text{if } c = c_0 \otimes c_1 \\
          span(c_0) + span(c_1) &\text{if } c = c_0 \oplus c_1
        \end{cases}
      \end{equation*}
  \end{itemize}
\end{frame}

\begin{frame}{Parallel Complexity Translation}
  \begin{align*}
    \|\LP e_0, e_1 \RP \| &= \LP \|e_0\|_c \otimes \|e_1\|_c, \LP \|e_0\|_p, \|e_1\|_p\RP\RP \\
    \|\lambda x.e\| &= \LP 0, \lambda x.\|e\| \RP \\
    \|e_0\ e_1\| &= 1 \oplus (\|e_0\|_c \otimes \|e_1\|_c) \oplus_c \|e_0\|_p\ \|e_1\|_p \\
    \|delay(e)\| &= \LP 0, \|e\|\RP \\
    \|force(e)\| &= \|e\|_c \oplus_c \|e\|_p
  \end{align*}
  Bounding relation: if $\gamma \vdash e : \tau$, then $e \sqsubseteq_\tau \|e\|$.
  Proof by logical relations.
\end{frame}

\begin{frame}{Mutual Recurrences}
  Pure Potential Translation
    \begin{align*}
      |\LP e_0, e_1 \RP | &= \LP |e_0|, |e_1| \RP                                  \\
      |\lambda x.e | &= \lambda x.|e|                                                              \\
      |e_0\ e_1| &= |e_0|\ |e_1|                                                                   \\
      |delay(e)| &= |e|                                                                            \\
      |force(e)| &= |e|
    \end{align*}
  \begin{theorem}
    For all $\gamma \vdash e : \tau$, $|e| : \LL \tau \RR \sim_\tau \|e\| : \|\tau\|$
  \end{theorem}
  \begin{proof}
    by logical relations
  \end{proof}
\end{frame}


\begin{frame}{Bibliography}
  \bibliography{bibliography}
  \bibliographystyle{plainnat}
\end{frame}

\end{document}
