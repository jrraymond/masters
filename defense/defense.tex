\documentclass[pdf]{beamer}
\usepackage{lmodern}
\usepackage{listings}

\mode<presentation>{}

\newcommand{\T}[1]{\texttt{#1}}
\newsavebox{\codebox}
\lstset{mathescape=true, basicstyle=\ttfamily}
\newcommand{\LP}{\langle}
\newcommand{\RP}{\rangle}

\title{Extracting Cost Recurrences from Sequential and Parallel Functional Programs}

\author{Justin Raymond}


\begin{document}

\begin{lrbox}{\codebox}
  \begin{lstlisting}
  rev xs = $\lambda$xs.rec(xs,
     Nil $\mapsto$ $\lambda$a.a,
     Cons$\mapsto$b.split(b,x.c.split(c,xs'.r.
        $\lambda$a.force(r) Cons$\LP$x,a$\RP$))) Nil
  \end{lstlisting}
\end{lrbox}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Abstract}
Complexity analysis aims to predict the resources, most often time and space,
which a program requires.  We build on previous work by Danner2013 and
Danner2015 which formalizes the extraction of recurrences for evaluation
cost from higher order functional programs. Source language programs are
translated into a complexity language. The translation of an expression is a
pair of a cost, a bound on the cost of evaluating the program to a value, and a
potential, the cost of future use of the value. We use the formalization to
analyze the time complexity of higher order functional programs. We also
demonstrate the flexibility of the method by extending it to parallel cost
semantics. Costs are cost graphs, which express dependencies between
subcomputations in the program. We prove by logical relations that the
extracted recurrences are an upper bound on the evaluation cost of the original
program. We also give examples of the analysis of higher order functional
programs under the parallel evaluation semantics.
\end{frame}


\begin{frame}{Fast Reverse - Specification and Implementation}
  \begin{itemize}
    \item
        $\T{datatype list} = \T{Nil of unit}\ |\ \T{Cons of int} \times \T{list}$
    \item
      Specification: \T{rev [$x_0,\dots,x_{n-1}$] = [$x_{n-1},\dots,x_0$]}
    \item
      Implementation:
      \usebox{\codebox}
    \item
      Specification of auxilary function:\\
      \T{rec($[x_0,\dots,x_{n-1}],\dots$) [$y_0,\dots,y_{m-1}$] = [$x_{n-1},\dots,x_0,y_0,\dots,y_{m-1}$]}
  \end{itemize}
\end{frame}

\begin{frame}{Fast Reverse - Specification and Implementation}
  \begin{itemize}
    \item
      \T{rev (Cons$\LP$0,Cons$\LP$1, Nil$\RP\RP$)}
    \item
    \T{$\to_\beta$
      rec(Cons$\LP$0,Cons$\LP$1,Nil$\RP\RP$,
          Nil $\mapsto\lambda$a.a
          Cons$\mapsto$b.split(b,x.c.split(c,xs'.r.
      $\lambda$a.force(r) Cons$\LP$x,a$\RP$))) Nil}
    \item
      \T{$\to^*_\beta (\lambda$a0.($\lambda$a1.($\lambda$a2.a2) Cons$\LP$1,a1$\RP$) Cons$\LP$0,a0$\RP$) Nil}
    \item
      $\to_\beta$ ($\lambda$a1.($\lambda$a2.a2) Cons$\LP$1,a1$\RP$) Cons$\LP$0,Nil$\RP$
    \item
      $\to_\beta$ ($\lambda$a2.a2) Cons$\LP$1,Cons$\LP$0,Nil$\RP\RP$
    \item
      $\to_\beta$ Cons$\LP$1,Cons$\LP$0,Nil$\RP\RP$
  \end{itemize}
\end{frame}

\begin{frame}{Fast Reverse - Translation}
\end{frame}

\begin{frame}{Fast Reverse - Interpretation}
\end{frame}

\begin{frame}{Parallel Cost Semantics}
\end{frame}

\begin{frame}{Pure Potential Translation}
\end{frame}
\end{document}
