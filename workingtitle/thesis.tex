\documentclass[11pt, ma]{westhesis}
\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{listings}
%\usepackage{ntheorem}
\usepackage{float}
\usepackage{upgreek}
\usepackage{stmaryrd}
\usepackage[font=small]{caption}
\usepackage{float}

% ND comments.
\usepackage[normalem]{ulem}
\setlength{\marginparwidth}{1.25in}
\reversemarginpar
\newcommand{\ndComment}[2][\relax]{\ifx#1\relax\else\uline{#1}\fi\marginpar{\renewcommand{\baselinestretch}{1.0}\tiny ND: {#2}}}
\newcommand{\ndTypo}[1]{\ndComment[#1]{$\longrightarrow$}}
\newcommand{\ndDel}[1]{\sout{#1}\ndComment{$\longrightarrow$}}

\newcommand{\LP}{\langle}
\newcommand{\RP}{\rangle}
\newcommand{\LB}{\llbracket}
\newcommand{\RB}{\rrbracket}
\newcommand{\quadthree}{\qquad\quad}
\newcommand{\quadfour}{\quadthree\quad}
\newcommand{\quadfive}{\quadfour\quad}
\newcommand{\quadsix}{\quadfive\quad}
\newcommand{\quadseven}{\quadsix\quad}
\newcommand{\quadeight}{\quadseven\quad}
\newcommand{\quadten}{\quadfive\quadfive}

\newcommand{\llangle}{\LP\!\LP}
\newcommand{\rrangle}{\RP\!\RP}
%\newcommand{\llambda}{\lambda\!\!\lambda}
%\newcommand{\pplus}{\raisebox{0.25ex}{+}\!\!\!\!\!+}

\makeatletter
\newcommand{\fs@singlerule}{%
	\fs@plain%
	\def\@fs@mid{\vskip1ex\hrule\vskip1ex}
}
\makeatother
\floatstyle{singlerule}
\restylefloat{figure}
\newfloat{program}{t}{pgm}
\floatname{program}{Program}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
  \ifmmode%
    \old@comma\discretionary{}{}{}%
  \else%
    \old@comma%
  \fi%
}
\makeatother

\allowdisplaybreaks


\department{Mathematics and Computer Science}
\submitdate{TDS}
\advisor{Norman Danner}

\title{Extracting Cost Recurrences from Sequential and Parallel Functional Programs}
\author{Justin Raymond}
\submitdate{\today}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[chapter]
%\newenvironment{definition}[1][Definition]{\begin{trivlist}
%\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\T}[1]{\texttt{#1}}
\lstset{mathescape=true,basicstyle=\ttfamily}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\begin{document}
%
\begin{abstract}
Complexity analysis aims to predict the resources, most often time and space,
which a program requires.  We build on previous work by \cite{Danner2013} and
\cite{Danner2015} which formalizes the extraction of recurrences for evaluation
cost from higher order functional programs. Source language programs are
translated into a complexity language. The translation of a program is a
pair of a cost, a bound on the cost of evaluating the program to a value, and a
potential, the cost of future use of the value. We use the formalization to
analyze the time complexity of higher order functional programs. We also
demonstrate the flexibility of the method by extending it to parallel cost
semantics. In parallel cost semantics, costs are cost graphs, which express
dependencies between subcomputations in the program. We prove by logical
relations that the extracted recurrences are an upper bound on the evaluation
cost of the original program. We also give examples of the analysis of higher
order functional programs under the parallel evaluation semantics. We also
prove the recurrence for the potential of a program does not depend on the cost
of the program.
\end{abstract}
%
\begin{acknowledgements}
  Thank you to my adviser Norman Danner for having the patience to put up with
  me the past year. Without him, this thesis would not have made it past the
  title page. Thanks also to Jim Lipton, Dan Licata, and Danny Krizanc who,
  along with Norman Danner, taught me everything I know about Computer Science.
  \par
  Thank you to my readers: Norman Danner, Dan Licata, and Saleh Aliyari.
\end{acknowledgements}
%

\frontmatter
\maketitle
\makededication
\makeack
\makeabstract        %TODO

\tableofcontents

\mainmatter
\include{Introduction}
\include{HigherOrderComplexityAnalysis}
\include{FastReverse}
\include{Reverse}
\include{ParametricInsertionSort}
%\include{InsertionSort}
\include{ListMap}
\include{TreeMap}
\include{WorkAndSpan}
\include{MutualRecurrence}
\include{Conclusion}

\bibliography{bibliography}
\bibliographystyle{plainnat}
\end{document}
