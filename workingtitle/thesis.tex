\documentclass[11pt, ma]{westhesis}
\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{listings}
%\usepackage{ntheorem}
\usepackage{float}
\usepackage{upgreek}
\usepackage{stmaryrd}

% ND comments.
\usepackage[normalem]{ulem}
\setlength{\marginparwidth}{1.25in}
\reversemarginpar
\newcommand{\ndComment}[2][\relax]{\ifx#1\relax\else\uline{#1}\fi\marginpar{\renewcommand{\baselinestretch}{1.0}\tiny ND: {#2}}}
\newcommand{\ndTypo}[1]{\ndComment[#1]{$\longrightarrow$}}
\newcommand{\ndDel}[1]{\sout{#1}\ndComment{$\longrightarrow$}}

\newcommand{\LP}{\langle}
\newcommand{\RP}{\rangle}
\newcommand{\LB}{\llbracket}
\newcommand{\RB}{\rrbracket}
\newcommand{\quadthree}{\qquad\quad}
\newcommand{\quadfour}{\quadthree\quad}
\newcommand{\quadfive}{\quadfour\quad}
\newcommand{\quadsix}{\quadfive\quad}
\newcommand{\quadseven}{\quadsix\quad}
\newcommand{\quadeight}{\quadseven\quad}
\newcommand{\quadten}{\quadfive\quadfive}

\newcommand{\llangle}{\LP\!\LP}
\newcommand{\rrangle}{\RP\!\RP}
%\newcommand{\llambda}{\lambda\!\!\lambda}
%\newcommand{\pplus}{\raisebox{0.25ex}{+}\!\!\!\!\!+}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
  \ifmmode%
    \old@comma\discretionary{}{}{}%
  \else%
    \old@comma%
  \fi%
}
\makeatother

\allowdisplaybreaks


\department{Mathematics and Computer Science}
\submitdate{TDS}
\advisor{Norman Danner}

\title{Extracting Cost Recurrences from Sequential and Parallel Functional Programs}
\author{Justin Raymond}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[chapter]
%\newenvironment{definition}[1][Definition]{\begin{trivlist}
%\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\T}[1]{\texttt{#1}}
\lstset{mathescape=true,basicstyle=\ttfamily}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\begin{document}
%
\begin{abstract}
Complexity analysis aims to predict the resources, most often time and space,
which a program requires.  We build on previous work by \cite{Danner2013} and
\cite{Danner2015} which formalizes the extraction of recurrences for evaluation
cost from higher order functional programs. Source language programs are
translated into a complexity language. The translation of an expression is a
pair of a cost, a bound on the cost of evaluating the program to a value, and a
potential, the cost of future use of the value. We use the formalization to
analyze the time complexity of higher order functional programs. We also
demonstrate the flexibility of the method by extending it to parallel cost
semantics. Costs are cost graphs, which express dependencies between
subcomputations in the program. We prove by logical relations that the
extracted recurrences are an upper bound on the evaluation cost of the original
program. We also give examples of the analysis of higher order functional
programs under the parallel evaluation semantics.
\end{abstract}
%
\begin{acknowledgements}
  Thank you to my adviser Norman Danner for having the patience to put up with
  me the past year. Without him, this thesis would not have made it past the
  title page. Thanks also to Jim Lipton, Dan Licata, and Danny Krizanc who,
  along with Norman Danner, taught me everything I know about computer science.
\end{acknowledgements}
%

\frontmatter
\maketitle
\makededication
\makeack
\makeabstract        %TODO

\tableofcontents

\mainmatter
\include{Introduction}
\include{HigherOrderComplexityAnalysis}
\include{FastReverse}
\include{Reverse}
\include{ParametricInsertionSort}
\include{InsertionSort}
\include{ListMap}
\include{TreeMap}
\include{WorkAndSpan}
\include{MutualRecurrence}
\include{Conclusion}

\bibliography{bibliography}
\bibliographystyle{plainnat}
\end{document}
