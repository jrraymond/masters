\chapter{Higher Order Complexity Analysis}

Programs are written in the {source language.
Then the program is translated to a complexity language.
The semantic interpretation of the complexity language program may be used to analyse the complexity of the original program.

\section{Source Language}
The source language is the simply typed lambda calculus with \T{unit}, product types, suspensions, inductive datatypes and a recursion construct.
The types, expressions, and typing judgments of the source language are given in figure \ref{fig:source_lang_syntax_types}.  
Evaluation is call-by-value and the rules for evaluation are given in figure \ref{fig:source_lang_oper_sem}.

\T{unit} is a type with only one inhabitant, the value $\langle\rangle$, also called \T{unit}.

Product types are a compound types consisting of an ordered pair of types.
Products are introduced using $\langle e_0, e_1 \rangle$
Since evaluation is call-by-value, products are strict.
So both expressions of in product must be evaluated before the product may be destructured.
Products are eliminated using \T{split}.

A suspension is an uncomputed computation that may be run in the future.
A suspension has type \T{susp} $\tau$ where $\tau$ is the type of the resulting computation.
Suspensions are introduced using the \T{delay}$(e)$ operator.
Suspensions are eliminated using the \T{force}$(e)$ operator.


A program using datatypes must have a top-level signature $\psi$ consisting of datatype declarations of the form
\[ \T{datatype} \delta = C^\delta_0 \T{of} \phi_{C_0}[\delta] \ |\ ...\ |\ C^\delta_{n-1} \T{of} \phi_{C_{n-1}}[\delta] \]
Each datatype may only refer to datatypes declared earlier in the signature. This prevents general recursive datatypes.
The argument to each constructor is given by a strictly positive functor $\phi$, which is one of $t$, $\tau$, $\phi_0 \times \phi_1$, and $\tau \rightarrow \phi$.
The identity functor $t$ represents recursive occurence of the datatype.
The constant functor $\tau$ represents a non-recursive type.
The product functor $\phi_0 \times \phi_1$ represents a pair of arguments.
The constant exponential $\tau \rightarrow \phi$ represents a function type.
The introduction forms for datatypes are the constructors.
The elimination form for a datatype is the \T{rec} construct.


The \T{rec} construct allows for structural recursion.
\T{rec} is given an argument to recurse on and a sequence of statements corresponding to each constructor for the datatype of the first argument.
The first argument to \T{rec} is evaluated to a value, and then depending on the outermost constructor of the value, \T{rec} evaluates to the appropriate branch.


\T{map} is used to witness functoriallity whatever that means.

\begin{figure}
\label{fig:source_lang_syntax_types}
Types
\begin{align*}
  \tau &::= \T{unit}\ |\ \tau \times \tau\ |\ \tau \rightarrow \tau\ |\ \T{susp}\ \tau\ |\ \delta \\
  \phi &::= t\ |\ \tau\ |\ \phi \times \phi\ |\ \tau \rightarrow \phi \\
  \T{datatype}\ \delta &= C^\delta_0 \T{of} \phi_{C_0}[\delta]\ |\ ...\ |\ C^\delta_{n-1} \T{of} \phi_{C_{n-1}}[\delta]
\end{align*}

Expressions
\begin{align*}
  v &::= x\ |\ \langle\rangle\ |\ \langle v, v \rangle\ |\ \lambda x.e\ |\ \T{delay}(e)\ |\ C\ v \\
  e &::= x\ |\ \langle\rangle\ |\ \langle e, e \rangle\ |\ \T{split}(e, x.x.e)\ |\ \lambda x.e\ |\ e\ e \\
    &\quad\ |\ \T{delay}(e)\ |\ \T{force}(e)\ |\ C^\delta\ e\ |\ \T{rec}^\delta(e, \overline{C \mapsto x.e_C}) \\
    &\quad\ |\ \T{map}^\phi(x.v, v)\ |\ \T{let}(e, x.e) \\
  n &::= 0\ |\ 1\ |\ n + n
\end{align*}

Typing Judgments

  \AxiomC{}
  \UnaryInfC{$\gamma, x : \sigma \vdash x : \sigma$}
  \DisplayProof
  \AxiomC{}
  \UnaryInfC{$\gamma \vdash \langle \rangle : \T{unit}$}
  \DisplayProof
  
  \bigskip

  \AxiomC{$\gamma \vdash e_0 : \tau_0$}
  \AxiomC{$\gamma \vdash e_1 : \tau_1$}
  \BinaryInfC{$\langle e_0, e_1 \rangle : \tau_0 \times \tau_1$}
  \DisplayProof
  \AxiomC{$\gamma \vdash e_0 : \tau_0 \times \tau_1$}
  \AxiomC{$\gamma, x_0 : \tau_0, x_1 : \tau_1 \vdash e_1 : \tau$}
  \BinaryInfC{$\gamma \vdash \T{split}(e_0, x_0.x_1.e_1) : \tau$}
  \DisplayProof

  \bigskip

  \AxiomC{$\gamma, x : \sigma \vdash e : \tau$}
  \UnaryInfC{$\gamma \vdash \lambda x.e : \sigma \rightarrow \tau$}
  \DisplayProof
  \AxiomC{$\gamma \vdash e_0 : \sigma \rightarrow \tau$}
  \AxiomC{$\gamma \vdash e_1 : \sigma$}
  \BinaryInfC{$\gamma \vdash e_0\ e_1 : \tau$}
  \DisplayProof

  \bigskip

  \AxiomC{$\gamma \vdash e : \tau$}
  \UnaryInfC{$\gamma \vdash \T{delay}(e) : \T{susp}\ \tau$}
  \DisplayProof
  \AxiomC{$\gamma \vdash e : \T{susp}\ \tau$}
  \UnaryInfC{$\gamma \vdash \T{force}(e) : \tau$}
  \DisplayProof

  \bigskip

  \AxiomC{$\gamma \vdash e : \phi_C[\delta]$}
  \UnaryInfC{$\gamma \vdash C^\delta\ e : \delta$}
  \DisplayProof
  \AxiomC{$\gamma \vdash e : \delta$}
  \AxiomC{$\forall C . \gamma, x : \phi_C[\delta \times \T{susp}\ \tau] \vdash e_C : \tau$}
  \BinaryInfC{$\gamma \vdash \T{rec}^\delta(e, \overline{C \mapsto x.e_C}) : \tau$}
  \DisplayProof

  \bigskip

  \AxiomC{$\gamma, x : \tau_0 \vdash v_1 : \tau_1$}
  \AxiomC{$\gamma \vdash v_0 : \phi[\tau_0]$}
  \BinaryInfC{$\T{map}^\phi(x.v_1, v_0) : \phi[\tau_1]$}
  \DisplayProof
  \AxiomC{$\gamma \vdash e_0 : \sigma$}
  \AxiomC{$\gamma, x : \sigma \vdash e_1 : \tau$}
  \BinaryInfC{$\T{let}(e_0, x.e_1) : \tau$}
  \DisplayProof
\end{figure}

\begin{figure}
  \label{fig:source_lang_oper_sem}
  \caption{Source language operational semantics}

  \bigskip

  \AxiomC{$e_0 \downarrow^{n_0} v_0$}
  \AxiomC{$e_1 \downarrow^{n_1} v_1$}
  \BinaryInfC{$\langle e_0, e_1 \rangle \downarrow^{n_0 + n_1} \langle v_0, v_1 \rangle$}
  \DisplayProof
  \AxiomC{$e_0 \downarrow^{n_0} \langle v_0, v_1 \rangle$}
  \AxiomC{$e_1[v_0/x_0, v_1/x_1] \downarrow^{n_1} v$}
  \BinaryInfC{$\T{split}(e_0, x_0.x_1.e_1) \downarrow^{n_0 + n_1} v$}
  \DisplayProof

  \bigskip

  \AxiomC{$e_0 \downarrow^{n_0} \lambda x.e_0'$}
  \AxiomC{$e_1 \downarrow^{n_1} v_1$}
  \AxiomC{$e_0'[v_1/x] \downarrow^n v$}
  \TrinaryInfC{$e_0\ e_1 \downarrow^{1 + n_0 + n_1 + n} v$}
  \DisplayProof
  \AxiomC{}
  \UnaryInfC{$\T{delay}(e) \downarrow^0 \T{delay}(e)$}
  \DisplayProof

  \bigskip

  \AxiomC{$e \downarrow^{n_0} \T{delay}(e_0)$}
  \AxiomC{$e_0 \downarrow^{n_1} v$}
  \BinaryInfC{$\T{force}(e) \downarrow^{n_0 + n_1} v$}
  \DisplayProof
  \AxiomC{$e \downarrow^n v$}
  \UnaryInfC{$C e \downarrow^n C v$}
  \DisplayProof

  \bigskip

  \AxiomC{$e \downarrow^{n_0} C v_0$}
  \AxiomC{$\T{map}^{\phi_C}(y.\langle y, \T{delay}(rec(y, \overline{C \mapsto x.e_C}))\rangle, v_0) \downarrow^{n_1} v_1$}
  \AxiomC{$e_C[v_1/x] \downarrow^{n_2} v$}
  \TrinaryInfC{$rec(e, \overline{C \mapsto x.e_C}) \downarrow^{1 + n_0 + n_1 + n_2} v$}
  \DisplayProof

  \bigskip

  \AxiomC{}
  \UnaryInfC{$\T{map}^t(x.v, v_0) \downarrow^0 v[v_0/x]$}
  \DisplayProof
  \AxiomC{}
  \UnaryInfC{$\T{map}^\tau(x.v, v_0) \downarrow^0 v_0$}
  \DisplayProof

  \bigskip

  \AxiomC{$\T{map}^{\phi_0}(x.v, v_0) \downarrow^{n_0} v_0'$}
  \AxiomC{$\T{map}^{\phi_1}(x.v, v_1) \downarrow^{n_1} v_1'$}
  \BinaryInfC{$\T{map}^{\phi_0 \times \phi_1}(x.v, \langle v_0, v_1 \rangle) \downarrow^{n_0 + n_1} \langle v_0', v_1'\rangle$}
  \DisplayProof

  \AxiomC{}
  \UnaryInfC{$\T{map}^{\tau \to \phi}(x.v, \lambda y.e) \downarrow^0 \lambda y.\T{let}(e, z.\T{map}^\phi(x.v, z))$}
  \DisplayProof
  \AxiomC{$e_0 \downarrow^{n_0} v_0$}
  \AxiomC{$e_1[v_0/x] \downarrow^{n_1} v$}
  \BinaryInfC{$\T{let}(e_0, x.e_1) \downarrow^{n_0 + n_1} v$}
  \DisplayProof
\end{figure}

\section{Complexity Language}

The types, expressions, and typing judgments of the complexity language are given in figure \ref{fig:complexity_lang}.
The complexity language is similar to the source language with a few exceptions.

Suspensions are no longer present.

Tuples are destructured using projections instead of \T{split}.

\begin{figure}
  \label{fig:complexity_lang}
  
  Types
  \begin{align*}
    T &::= \textbf{C} \ |\ \T{unit} \ |\ \Delta \ |\ T \times T \ |\ T \rightarrow T \\
    \Phi &::= t \ |\ T \ |\ \Phi \times \Phi \ |\ T \rightarrow \Phi \\
    \textbf{C} &::= 0\ |\ 1\ |\ 2\ |\ ... \\
    \T{datatype}\Delta &= C^\Delta_0 \T{of} \Phi_{C_0}[\Delta] \ |\ ... \ |\ C^\Delta_{n-1} \T{of} \Phi_{C_{n-1}}[\Delta]
  \end{align*}

  Expressions
  \begin{align*}
    E &::= x | 0 | 1 | E + E | \langle\rangle | \langle E,E \rangle | \\
      &\quad \pi_0 E | \pi_1 E | \lambda x.E | E\ E | C^\delta\ E | \text{rec}^\Delta(E, \overline{C \mapsto x.E_C})
  \end{align*}

  Typing Judgments

  \bigskip

  \AxiomC{}
  \UnaryInfC{$\Gamma, x : T \vdash x : T$}
  \DisplayProof
  \AxiomC{}
  \UnaryInfC{$\Gamma \vdash 0 : \textbf{C}$}
  \DisplayProof
  \AxiomC{}
  \UnaryInfC{$\Gamma \vdash 1 : \textbf{C}$}
  \DisplayProof
  \AxiomC{}
  \UnaryInfC{$\Gamma \vdash \langle\rangle : \textbf{unit}$}
  \DisplayProof

  \bigskip

  \AxiomC{$\Gamma \vdash E_0 : \textbf{C}$}
  \AxiomC{$\Gamma \vdash E_1 : \textbf{C}$}
  \BinaryInfC{$\Gamma \vdash E_0 + E_1 : \textbf{C}$}
  \DisplayProof
  \AxiomC{$\Gamma \vdash E_0 : T_0$}
  \AxiomC{$\Gamma \vdash E_1 : T_1$}
  \BinaryInfC{$\Gamma \vdash \langle E_0, E_1 \rangle : T_0 \times T_1$}
  \DisplayProof

  \bigskip

  \AxiomC{$\Gamma \vdash E : T_0 \times T_1$}
  \UnaryInfC{$\Gamma \vdash \pi_i E : T_i$}
  \DisplayProof
  \AxiomC{$\Gamma, x : T_0 \vdash E : T_1$}
  \UnaryInfC{$\Gamma \vdash \lambda x.E : T_0 \rightarrow T_1$}
  \DisplayProof

  \bigskip

  \AxiomC{$\Gamma \vdash E_0 : T_0 \rightarrow T_1$}
  \AxiomC{$\Gamma \vdash E_1 : T_0$}
  \BinaryInfC{$\Gamma \vdash E_0\ E_1 : T_1$}
  \DisplayProof
  \AxiomC{$\Gamma \vdash E : \Phi_C[\Delta]$}
  \UnaryInfC{$\Gamma \vdash C^\Delta E : \Delta$}
  \DisplayProof

  \bigskip

  \AxiomC{$\Gamma \vdash E : \Delta$}
  \AxiomC{$\forall C . \Gamma, x : \Phi_C[\Delta \times T] \vdash E_C : T$}
  \BinaryInfC{$\Gamma \vdash \text{rec}^\Delta(E, \overline{C \mapsto x.E_C}) : T$}
  \DisplayProof

\end{figure}
